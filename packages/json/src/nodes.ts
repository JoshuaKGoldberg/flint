import type * as ts from "typescript";

// TODO: This copies the @flint/ts TSNodesByName.
// It should be trimmed down to just the JSON nodes.

// TODO: Surely there's a better way to do this...
// ...but I haven't checked how to do it without slow type operations.

export interface TSNodesByName {
	ArrayBindingPattern: ts.ArrayBindingPattern;
	ArrayLiteralExpression: ts.ArrayLiteralExpression;
	ArrowFunction: ts.ArrowFunction;
	AsExpression: ts.AsExpression;
	AwaitExpression: ts.AwaitExpression;
	BigIntLiteral: ts.BigIntLiteral;
	BinaryExpression: ts.BinaryExpression;
	BindingElement: ts.BindingElement;
	Block: ts.Block;
	BreakStatement: ts.BreakStatement;
	Bundle: ts.Bundle;
	CallExpression: ts.CallExpression;
	CaseBlock: ts.CaseBlock;
	CaseClause: ts.CaseClause;
	CatchClause: ts.CatchClause;
	ClassDeclaration: ts.ClassDeclaration;
	ClassExpression: ts.ClassExpression;
	ClassStaticBlockDeclaration: ts.ClassStaticBlockDeclaration;
	CommaListExpression: ts.CommaListExpression;
	ComputedPropertyName: ts.ComputedPropertyName;
	ConditionalExpression: ts.ConditionalExpression;
	ConditionalType: ts.ConditionalType;
	ContinueStatement: ts.ContinueStatement;
	DebuggerStatement: ts.DebuggerStatement;
	Decorator: ts.Decorator;
	DefaultClause: ts.DefaultClause;
	DeleteExpression: ts.DeleteExpression;
	DoStatement: ts.DoStatement;
	ElementAccessExpression: ts.ElementAccessExpression;
	EmptyStatement: ts.EmptyStatement;
	EnumDeclaration: ts.EnumDeclaration;
	EnumMember: ts.EnumMember;
	ExportAssignment: ts.ExportAssignment;
	ExportDeclaration: ts.ExportDeclaration;
	ExportSpecifier: ts.ExportSpecifier;
	ExpressionStatement: ts.ExpressionStatement;
	ExpressionWithTypeArguments: ts.ExpressionWithTypeArguments;
	ExternalModuleReference: ts.ExternalModuleReference;
	ForInStatement: ts.ForInStatement;
	ForOfStatement: ts.ForOfStatement;
	ForStatement: ts.ForStatement;
	FunctionDeclaration: ts.FunctionDeclaration;
	FunctionExpression: ts.FunctionExpression;
	HeritageClause: ts.HeritageClause;
	Identifier: ts.Identifier;
	IfStatement: ts.IfStatement;
	ImportAttribute: ts.ImportAttribute;
	ImportAttributes: ts.ImportAttributes;
	ImportClause: ts.ImportClause;
	ImportDeclaration: ts.ImportDeclaration;
	ImportEqualsDeclaration: ts.ImportEqualsDeclaration;
	ImportSpecifier: ts.ImportSpecifier;
	IndexedAccessType: ts.IndexedAccessType;
	InterfaceDeclaration: ts.InterfaceDeclaration;
	IntersectionType: ts.IntersectionType;
	JsxAttribute: ts.JsxAttribute;
	JsxAttributes: ts.JsxAttributes;
	JsxClosingElement: ts.JsxClosingElement;
	JsxClosingFragment: ts.JsxClosingFragment;
	JsxElement: ts.JsxElement;
	JsxExpression: ts.JsxExpression;
	JsxFragment: ts.JsxFragment;
	JsxNamespacedName: ts.JsxNamespacedName;
	JsxOpeningElement: ts.JsxOpeningElement;
	JsxOpeningFragment: ts.JsxOpeningFragment;
	JsxSelfClosingElement: ts.JsxSelfClosingElement;
	JsxSpreadAttribute: ts.JsxSpreadAttribute;
	JsxText: ts.JsxText;
	LabeledStatement: ts.LabeledStatement;
	LiteralType: ts.LiteralType;
	MappedTypeNode: ts.MappedTypeNode;
	MetaProperty: ts.MetaProperty;
	MethodDeclaration: ts.MethodDeclaration;
	MethodSignature: ts.MethodSignature;
	MissingDeclaration: ts.MissingDeclaration;
	ModuleBlock: ts.ModuleBlock;
	ModuleDeclaration: ts.ModuleDeclaration;
	NamedExports: ts.NamedExports;
	NamedImports: ts.NamedImports;
	NamedTupleMember: ts.NamedTupleMember;
	NamespaceExport: ts.NamespaceExport;
	NamespaceExportDeclaration: ts.NamespaceExportDeclaration;
	NamespaceImport: ts.NamespaceImport;
	NewExpression: ts.NewExpression;
	NonNullExpression: ts.NonNullExpression;
	NoSubstitutionTemplateLiteral: ts.NoSubstitutionTemplateLiteral;
	NotEmittedStatement: ts.NotEmittedStatement;
	NotEmittedTypeElement: ts.NotEmittedTypeElement;
	NumericLiteral: ts.NumericLiteral;
	ObjectBindingPattern: ts.ObjectBindingPattern;
	ObjectLiteralExpression: ts.ObjectLiteralExpression;
	OmittedExpression: ts.OmittedExpression;
	ParenthesizedExpression: ts.ParenthesizedExpression;
	PartiallyEmittedExpression: ts.PartiallyEmittedExpression;
	PostfixUnaryExpression: ts.PostfixUnaryExpression;
	PrefixUnaryExpression: ts.PrefixUnaryExpression;
	PrivateIdentifier: ts.PrivateIdentifier;
	PropertyAccessExpression: ts.PropertyAccessExpression;
	PropertyAssignment: ts.PropertyAssignment;
	PropertyDeclaration: ts.PropertyDeclaration;
	PropertySignature: ts.PropertySignature;
	QualifiedName: ts.QualifiedName;
	RegularExpressionLiteral: ts.RegularExpressionLiteral;
	ReturnStatement: ts.ReturnStatement;
	SatisfiesExpression: ts.SatisfiesExpression;
	SemicolonClassElement: ts.SemicolonClassElement;
	ShorthandPropertyAssignment: ts.ShorthandPropertyAssignment;
	SourceFile: ts.SourceFile;
	SpreadAssignment: ts.SpreadAssignment;
	SpreadElement: ts.SpreadElement;
	StringLiteral: ts.StringLiteral;
	SwitchStatement: ts.SwitchStatement;
	SyntaxList: ts.SyntaxList;
	SyntheticExpression: ts.SyntheticExpression;
	TaggedTemplateExpression: ts.TaggedTemplateExpression;
	TemplateExpression: ts.TemplateExpression;
	TemplateHead: ts.TemplateHead;
	TemplateLiteralType: ts.TemplateLiteralType;
	TemplateLiteralTypeSpan: ts.TemplateLiteralTypeSpan;
	TemplateMiddle: ts.TemplateMiddle;
	TemplateSpan: ts.TemplateSpan;
	TemplateTail: ts.TemplateTail;
	ThrowStatement: ts.ThrowStatement;
	TryStatement: ts.TryStatement;
	TupleType: ts.TupleType;
	TypeAliasDeclaration: ts.TypeAliasDeclaration;
	TypeOfExpression: ts.TypeOfExpression;
	TypeParameter: ts.TypeParameter;
	TypePredicate: ts.TypePredicate;
	TypeReference: ts.TypeReference;
	UnionType: ts.UnionType;
	VariableDeclaration: ts.VariableDeclaration;
	VariableDeclarationList: ts.VariableDeclarationList;
	VariableStatement: ts.VariableStatement;
	VoidExpression: ts.VoidExpression;
	WhileStatement: ts.WhileStatement;
	WithStatement: ts.WithStatement;
	YieldExpression: ts.YieldExpression;
}
