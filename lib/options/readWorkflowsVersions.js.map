{"version":3,"file":"readWorkflowsVersions.js","names":["workflowsVersions: WorkflowsVersions"],"sources":["../../src/options/readWorkflowsVersions.ts"],"sourcesContent":["import { TakeInput } from \"bingo\";\nimport { inputFromFile } from \"input-from-file\";\n\nimport { inputFromDirectory } from \"../inputs/inputFromDirectory.js\";\nimport { WorkflowsVersions } from \"../schemas.js\";\nimport { swallowErrorAsync } from \"../utils/swallowErrorAsync.js\";\n\nexport async function readWorkflowsVersions(\n\ttake: TakeInput,\n): Promise<WorkflowsVersions> {\n\tconst workflowsVersions: WorkflowsVersions = {};\n\n\t// TODO: This would be more straightforward if bingo-fs provided globbing...\n\t// If you want to increase test coverage here, please do that first :)\n\t// https://github.com/JoshuaKGoldberg/bingo/issues/308\n\n\tasync function collectCompositeUses() {\n\t\tconst compositeNames = await take(inputFromDirectory, {\n\t\t\tdirectoryPath: \".github/actions\",\n\t\t});\n\n\t\tawait Promise.all(\n\t\t\tcompositeNames.map(async (compositeName) => {\n\t\t\t\tconst compositeFileNames = await take(inputFromDirectory, {\n\t\t\t\t\tdirectoryPath: `.github/actions/${compositeName}`,\n\t\t\t\t});\n\n\t\t\t\tfor (const compositeFileName of compositeFileNames) {\n\t\t\t\t\tawait collectFile(\n\t\t\t\t\t\t`.github/actions/${compositeName}/${compositeFileName}`,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}),\n\t\t);\n\t}\n\n\tasync function collectWorkflowUses() {\n\t\tconst workflowFileNames = await take(inputFromDirectory, {\n\t\t\tdirectoryPath: \".github/workflows\",\n\t\t});\n\n\t\tawait Promise.all(\n\t\t\tworkflowFileNames.map(async (workflowFileName) => {\n\t\t\t\tawait collectFile(`.github/workflows/${workflowFileName}`);\n\t\t\t}),\n\t\t);\n\t}\n\n\tasync function collectFile(filePath: string) {\n\t\tconst raw = await take(inputFromFile, { filePath });\n\t\tif (raw instanceof Error) {\n\t\t\treturn;\n\t\t}\n\n\t\tfor (const match of raw.matchAll(/uses:\\s*(\\w.+)/g)) {\n\t\t\tconst [, uses] = match;\n\t\t\tcollectUses(uses);\n\t\t}\n\t}\n\n\tfunction collectUses(uses: string) {\n\t\tconst matched = /([^#@]+)@([^ #]+)(?: # ([a-z\\d.]+))?/.exec(uses);\n\t\tif (!matched) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst [, action, actual, commented] = matched;\n\n\t\tworkflowsVersions[action] ??= {};\n\n\t\tif (commented) {\n\t\t\tworkflowsVersions[action][commented] ??= {};\n\t\t\tworkflowsVersions[action][commented].hash = actual;\n\t\t} else {\n\t\t\tworkflowsVersions[action][actual] ??= {};\n\t\t\tworkflowsVersions[action][actual].pinned = true;\n\t\t}\n\t}\n\n\tawait Promise.all([\n\t\tswallowErrorAsync(collectCompositeUses()),\n\t\tswallowErrorAsync(collectWorkflowUses()),\n\t]);\n\n\treturn workflowsVersions;\n}\n"],"mappings":";;;;;AAOA,eAAsB,sBACrB,MAC6B;CAC7B,MAAMA,oBAAuC,EAAE;CAM/C,eAAe,uBAAuB;EACrC,MAAM,iBAAiB,MAAM,KAAK,oBAAoB,EACrD,eAAe,mBACf,CAAC;AAEF,QAAM,QAAQ,IACb,eAAe,IAAI,OAAO,kBAAkB;GAC3C,MAAM,qBAAqB,MAAM,KAAK,oBAAoB,EACzD,eAAe,mBAAmB,iBAClC,CAAC;AAEF,QAAK,MAAM,qBAAqB,mBAC/B,OAAM,YACL,mBAAmB,cAAc,GAAG,oBACpC;IAED,CACF;;CAGF,eAAe,sBAAsB;EACpC,MAAM,oBAAoB,MAAM,KAAK,oBAAoB,EACxD,eAAe,qBACf,CAAC;AAEF,QAAM,QAAQ,IACb,kBAAkB,IAAI,OAAO,qBAAqB;AACjD,SAAM,YAAY,qBAAqB,mBAAmB;IACzD,CACF;;CAGF,eAAe,YAAY,UAAkB;EAC5C,MAAM,MAAM,MAAM,KAAK,eAAe,EAAE,UAAU,CAAC;AACnD,MAAI,eAAe,MAClB;AAGD,OAAK,MAAM,SAAS,IAAI,SAAS,kBAAkB,EAAE;GACpD,MAAM,GAAG,QAAQ;AACjB,eAAY,KAAK;;;CAInB,SAAS,YAAY,MAAc;EAClC,MAAM,UAAU,uCAAuC,KAAK,KAAK;AACjE,MAAI,CAAC,QACJ;EAGD,MAAM,GAAG,QAAQ,QAAQ,aAAa;AAEtC,oBAAkB,YAAY,EAAE;AAEhC,MAAI,WAAW;AACd,qBAAkB,QAAQ,eAAe,EAAE;AAC3C,qBAAkB,QAAQ,WAAW,OAAO;SACtC;AACN,qBAAkB,QAAQ,YAAY,EAAE;AACxC,qBAAkB,QAAQ,QAAQ,SAAS;;;AAI7C,OAAM,QAAQ,IAAI,CACjB,kBAAkB,sBAAsB,CAAC,EACzC,kBAAkB,qBAAqB,CAAC,CACxC,CAAC;AAEF,QAAO"}